# Anchor Framework for Solana Development

## Overview

Anchor is the most popular framework for building Solana programs, providing a high-level abstraction layer that simplifies program development. It offers automatic serialization, built-in security checks, testing utilities, and IDL generation, making it the preferred choice for modern Solana development.

**Estimated Time:** 3-4 hours

## Learning Objectives

After completing this lesson, you will be able to:

- Understand Anchor's architecture and key features
- Build Solana programs using Anchor's declarative syntax
- Implement account validation using Anchor's constraint system
- Write and run tests using Anchor's testing framework
- Generate and use Interface Definition Language (IDL) files
- Deploy and upgrade Anchor programs

## Prerequisites

- Completed [Accounts and Programs](../01-accounts-and-programs/README.md)
- Completed [Rust and Anchor Setup](../../setup/rust-anchor.md)
- Basic Rust programming knowledge
- Understanding of Solana's account model

## Why Use Anchor?

### Without Anchor (Native Solana)

```rust
use solana_program::{
    account_info::{next_account_info, AccountInfo},
    entrypoint,
    entrypoint::ProgramResult,
    program_error::ProgramError,
    pubkey::Pubkey,
};
use borsh::{BorshDeserialize, BorshSerialize};

#[derive(BorshSerialize, BorshDeserialize)]
pub struct Counter {
    pub count: u64,
}

entrypoint!(process_instruction);

pub fn process_instruction(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    instruction_data: &[u8],
) -> ProgramResult {
    let accounts_iter = &mut accounts.iter();
    let counter_account = next_account_info(accounts_iter)?;
    
    // Manual validation
    if counter_account.owner != program_id {
        return Err(ProgramError::IncorrectProgramId);
    }
    
    if !counter_account.is_writable {
        return Err(ProgramError::InvalidAccountData);
    }
    
    // Manual deserialization
    let mut counter = Counter::try_from_slice(&counter_account.data.borrow())?;
    counter.count += 1;
    
    // Manual serialization
    counter.serialize(&mut &mut counter_account.data.borrow_mut()[..])?;
    
    Ok(())
}
```

### With Anchor

```rust
use anchor_lang::prelude::*;

declare_id!("YOUR_PROGRAM_ID");

#[program]
pub mod counter {
    use super::*;
    
    pub fn increment(ctx: Context<Increment>) -> Result<()> {
        ctx.accounts.counter.count += 1;
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Increment<'info> {
    #[account(mut)]
    pub counter: Account<'info, Counter>,
}

#[account]
pub struct Counter {
    pub count: u64,
}
```

**Benefits:**
- Automatic serialization/deserialization
- Built-in account validation
- Type-safe account access
- Cleaner, more readable code
- Reduced boilerplate

## Anchor Architecture

### Core Components

1. **Program Module** (`#[program]`)
   - Contains instruction handlers
   - Defines program logic

2. **Accounts Structs** (`#[derive(Accounts)]`)
   - Defines account requirements for instructions
   - Includes validation constraints

3. **Account Types** (`#[account]`)
   - Defines data structures stored in accounts
   - Automatically handles serialization

4. **Errors** (`#[error_code]`)
   - Custom error definitions
   - Type-safe error handling

## Getting Started with Anchor

### Project Structure

```
my-anchor-project/
├── Anchor.toml              # Anchor configuration
├── Cargo.toml               # Rust workspace
├── package.json             # Node.js dependencies
├── programs/
│   └── my-program/
│       ├── Cargo.toml
│       ├── Xargo.toml
│       └── src/
│           └── lib.rs       # Program code
├── tests/
│   └── my-program.ts        # Integration tests
├── migrations/
│   └── deploy.ts            # Deployment scripts
└── target/
    ├── deploy/              # Compiled programs
    ├── idl/                 # Generated IDL files
    └── types/               # TypeScript types
```

### Basic Program Template

```rust
use anchor_lang::prelude::*;

// Program ID (generated by `anchor keys list`)
declare_id!("YOUR_PROGRAM_ID_HERE");

#[program]
pub mod my_program {
    use super::*;

    pub fn initialize(ctx: Context<Initialize>, data: u64) -> Result<()> {
        let my_account = &mut ctx.accounts.my_account;
        my_account.data = data;
        my_account.authority = ctx.accounts.authority.key();
        Ok(())
    }

    pub fn update(ctx: Context<Update>, new_data: u64) -> Result<()> {
        let my_account = &mut ctx.accounts.my_account;
        my_account.data = new_data;
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(
        init,
        payer = authority,
        space = 8 + 8 + 32
    )]
    pub my_account: Account<'info, MyAccount>,
    #[account(mut)]
    pub authority: Signer<'info>,
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct Update<'info> {
    #[account(
        mut,
        has_one = authority
    )]
    pub my_account: Account<'info, MyAccount>,
    pub authority: Signer<'info>,
}

#[account]
pub struct MyAccount {
    pub data: u64,
    pub authority: Pubkey,
}
```

## Account Constraints

Anchor provides powerful constraint macros for account validation:

### Common Constraints

#### `init` - Initialize a new account

```rust
#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(
        init,
        payer = user,
        space = 8 + 32 + 8  // discriminator + pubkey + u64
    )]
    pub my_account: Account<'info, MyAccount>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,
}
```

#### `mut` - Account must be mutable

```rust
#[account(mut)]
pub my_account: Account<'info, MyAccount>,
```

#### `has_one` - Validate account field matches

```rust
#[account(
    mut,
    has_one = authority  // Checks my_account.authority == authority.key()
)]
pub my_account: Account<'info, MyAccount>,
pub authority: Signer<'info>,
```

#### `constraint` - Custom validation

```rust
#[account(
    mut,
    constraint = my_account.count < 100 @ ErrorCode::CountTooHigh
)]
pub my_account: Account<'info, MyAccount>,
```

#### `seeds` and `bump` - PDA validation

```rust
#[account(
    seeds = [b"my-seed", authority.key().as_ref()],
    bump
)]
pub pda_account: Account<'info, MyAccount>,
pub authority: Signer<'info>,
```

#### `close` - Close account and return rent

```rust
#[account(
    mut,
    close = authority  // Returns rent to authority
)]
pub my_account: Account<'info, MyAccount>,
#[account(mut)]
pub authority: Signer<'info>,
```

### Account Types

Anchor provides several account wrapper types:

```rust
// Regular account with deserialization
pub account: Account<'info, MyAccount>,

// Unchecked account (use with caution)
pub unchecked_account: UncheckedAccount<'info>,

// Signer account
pub signer: Signer<'info>,

// Program account
pub system_program: Program<'info, System>,

// System account (AccountInfo wrapper)
/// CHECK: This is safe because we don't read or write
pub system_account: SystemAccount<'info>,

// Account loader for large accounts (zero-copy)
pub large_account: AccountLoader<'info, LargeAccount>,
```

## Complete Example: Task Manager

Let's build a complete task management program:

### Program Code

```rust
use anchor_lang::prelude::*;

declare_id!("YOUR_PROGRAM_ID");

#[program]
pub mod task_manager {
    use super::*;

    pub fn create_task_list(ctx: Context<CreateTaskList>) -> Result<()> {
        let task_list = &mut ctx.accounts.task_list;
        task_list.authority = ctx.accounts.authority.key();
        task_list.task_count = 0;
        Ok(())
    }

    pub fn add_task(
        ctx: Context<AddTask>,
        description: String,
    ) -> Result<()> {
        require!(description.len() <= 200, ErrorCode::DescriptionTooLong);
        
        let task_list = &mut ctx.accounts.task_list;
        let task = &mut ctx.accounts.task;
        
        task.task_list = task_list.key();
        task.description = description;
        task.completed = false;
        task.task_id = task_list.task_count;
        
        task_list.task_count += 1;
        
        Ok(())
    }

    pub fn complete_task(ctx: Context<CompleteTask>) -> Result<()> {
        let task = &mut ctx.accounts.task;
        require!(!task.completed, ErrorCode::TaskAlreadyCompleted);
        task.completed = true;
        Ok(())
    }

    pub fn delete_task(ctx: Context<DeleteTask>) -> Result<()> {
        // Account will be closed automatically due to `close` constraint
        Ok(())
    }
}

#[derive(Accounts)]
pub struct CreateTaskList<'info> {
    #[account(
        init,
        payer = authority,
        space = 8 + 32 + 8,  // discriminator + pubkey + u64
        seeds = [b"task-list", authority.key().as_ref()],
        bump
    )]
    pub task_list: Account<'info, TaskList>,
    #[account(mut)]
    pub authority: Signer<'info>,
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
#[instruction(description: String)]
pub struct AddTask<'info> {
    #[account(
        mut,
        has_one = authority,
        seeds = [b"task-list", authority.key().as_ref()],
        bump
    )]
    pub task_list: Account<'info, TaskList>,
    #[account(
        init,
        payer = authority,
        space = 8 + 32 + 4 + description.len() + 1 + 8,
        seeds = [
            b"task",
            task_list.key().as_ref(),
            task_list.task_count.to_le_bytes().as_ref()
        ],
        bump
    )]
    pub task: Account<'info, Task>,
    #[account(mut)]
    pub authority: Signer<'info>,
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct CompleteTask<'info> {
    #[account(
        mut,
        has_one = task_list
    )]
    pub task: Account<'info, Task>,
    #[account(
        has_one = authority
    )]
    pub task_list: Account<'info, TaskList>,
    pub authority: Signer<'info>,
}

#[derive(Accounts)]
pub struct DeleteTask<'info> {
    #[account(
        mut,
        has_one = task_list,
        close = authority
    )]
    pub task: Account<'info, Task>,
    #[account(
        has_one = authority
    )]
    pub task_list: Account<'info, TaskList>,
    #[account(mut)]
    pub authority: Signer<'info>,
}

#[account]
pub struct TaskList {
    pub authority: Pubkey,
    pub task_count: u64,
}

#[account]
pub struct Task {
    pub task_list: Pubkey,
    pub description: String,
    pub completed: bool,
    pub task_id: u64,
}

#[error_code]
pub enum ErrorCode {
    #[msg("Description must be 200 characters or less")]
    DescriptionTooLong,
    #[msg("Task is already completed")]
    TaskAlreadyCompleted,
}
```

### Client Code (TypeScript)

```typescript
import * as anchor from "@coral-xyz/anchor";
import { Program } from "@coral-xyz/anchor";
import { TaskManager } from "../target/types/task_manager";
import { PublicKey } from "@solana/web3.js";

describe("task-manager", () => {
  const provider = anchor.AnchorProvider.env();
  anchor.setProvider(provider);

  const program = anchor.workspace.TaskManager as Program<TaskManager>;
  const authority = provider.wallet.publicKey;

  let taskListPda: PublicKey;
  let taskListBump: number;

  before(async () => {
    // Derive task list PDA
    [taskListPda, taskListBump] = PublicKey.findProgramAddressSync(
      [Buffer.from("task-list"), authority.toBuffer()],
      program.programId
    );
  });

  it("Creates a task list", async () => {
    await program.methods
      .createTaskList()
      .accounts({
        taskList: taskListPda,
        authority: authority,
        systemProgram: anchor.web3.SystemProgram.programId,
      })
      .rpc();

    const taskList = await program.account.taskList.fetch(taskListPda);
    assert.equal(taskList.taskCount.toNumber(), 0);
    assert.equal(taskList.authority.toString(), authority.toString());
  });

  it("Adds a task", async () => {
    const description = "Complete Anchor tutorial";
    
    // Derive task PDA
    const [taskPda] = PublicKey.findProgramAddressSync(
      [
        Buffer.from("task"),
        taskListPda.toBuffer(),
        Buffer.from([0, 0, 0, 0, 0, 0, 0, 0]), // task_count = 0
      ],
      program.programId
    );

    await program.methods
      .addTask(description)
      .accounts({
        taskList: taskListPda,
        task: taskPda,
        authority: authority,
        systemProgram: anchor.web3.SystemProgram.programId,
      })
      .rpc();

    const task = await program.account.task.fetch(taskPda);
    assert.equal(task.description, description);
    assert.equal(task.completed, false);
    assert.equal(task.taskId.toNumber(), 0);

    const taskList = await program.account.taskList.fetch(taskListPda);
    assert.equal(taskList.taskCount.toNumber(), 1);
  });

  it("Completes a task", async () => {
    const [taskPda] = PublicKey.findProgramAddressSync(
      [
        Buffer.from("task"),
        taskListPda.toBuffer(),
        Buffer.from([0, 0, 0, 0, 0, 0, 0, 0]),
      ],
      program.programId
    );

    await program.methods
      .completeTask()
      .accounts({
        task: taskPda,
        taskList: taskListPda,
        authority: authority,
      })
      .rpc();

    const task = await program.account.task.fetch(taskPda);
    assert.equal(task.completed, true);
  });

  it("Deletes a task", async () => {
    const [taskPda] = PublicKey.findProgramAddressSync(
      [
        Buffer.from("task"),
        taskListPda.toBuffer(),
        Buffer.from([0, 0, 0, 0, 0, 0, 0, 0]),
      ],
      program.programId
    );

    await program.methods
      .deleteTask()
      .accounts({
        task: taskPda,
        taskList: taskListPda,
        authority: authority,
      })
      .rpc();

    // Task account should no longer exist
    try {
      await program.account.task.fetch(taskPda);
      assert.fail("Task account should be closed");
    } catch (err) {
      assert.ok(err.message.includes("Account does not exist"));
    }
  });
});
```

## Cross-Program Invocations (CPI)

Anchor simplifies calling other programs:

```rust
use anchor_lang::prelude::*;
use anchor_spl::token::{self, Token, TokenAccount, Transfer};

#[program]
pub mod my_program {
    use super::*;

    pub fn transfer_tokens(ctx: Context<TransferTokens>, amount: u64) -> Result<()> {
        // Create CPI context
        let cpi_accounts = Transfer {
            from: ctx.accounts.from.to_account_info(),
            to: ctx.accounts.to.to_account_info(),
            authority: ctx.accounts.authority.to_account_info(),
        };
        
        let cpi_program = ctx.accounts.token_program.to_account_info();
        let cpi_ctx = CpiContext::new(cpi_program, cpi_accounts);
        
        // Execute CPI
        token::transfer(cpi_ctx, amount)?;
        
        Ok(())
    }
}

#[derive(Accounts)]
pub struct TransferTokens<'info> {
    #[account(mut)]
    pub from: Account<'info, TokenAccount>,
    #[account(mut)]
    pub to: Account<'info, TokenAccount>,
    pub authority: Signer<'info>,
    pub token_program: Program<'info, Token>,
}
```

### CPI with PDA Signer

```rust
pub fn transfer_with_pda(ctx: Context<TransferWithPda>, amount: u64) -> Result<()> {
    let seeds = &[
        b"authority",
        ctx.accounts.my_account.key().as_ref(),
        &[ctx.bumps.pda_authority],
    ];
    let signer_seeds = &[&seeds[..]];
    
    let cpi_accounts = Transfer {
        from: ctx.accounts.from.to_account_info(),
        to: ctx.accounts.to.to_account_info(),
        authority: ctx.accounts.pda_authority.to_account_info(),
    };
    
    let cpi_program = ctx.accounts.token_program.to_account_info();
    let cpi_ctx = CpiContext::new_with_signer(
        cpi_program,
        cpi_accounts,
        signer_seeds
    );
    
    token::transfer(cpi_ctx, amount)?;
    
    Ok(())
}
```

## Testing with Anchor

### Test Setup

```typescript
import * as anchor from "@coral-xyz/anchor";
import { Program } from "@coral-xyz/anchor";
import { MyProgram } from "../target/types/my_program";
import { assert } from "chai";

describe("my-program", () => {
  // Configure the client
  const provider = anchor.AnchorProvider.env();
  anchor.setProvider(provider);

  const program = anchor.workspace.MyProgram as Program<MyProgram>;
  
  it("Test case", async () => {
    // Your test code
  });
});
```

### Common Test Patterns

```typescript
// Create test accounts
const testAccount = anchor.web3.Keypair.generate();

// Airdrop SOL for testing
await provider.connection.requestAirdrop(
  testAccount.publicKey,
  2 * anchor.web3.LAMPORTS_PER_SOL
);

// Call program instruction
await program.methods
  .initialize(new anchor.BN(42))
  .accounts({
    myAccount: testAccount.publicKey,
    authority: provider.wallet.publicKey,
    systemProgram: anchor.web3.SystemProgram.programId,
  })
  .signers([testAccount])
  .rpc();

// Fetch and verify account data
const account = await program.account.myAccount.fetch(testAccount.publicKey);
assert.equal(account.data.toNumber(), 42);

// Test error cases
try {
  await program.methods
    .invalidOperation()
    .accounts({ /* ... */ })
    .rpc();
  assert.fail("Should have thrown error");
} catch (err) {
  assert.ok(err.message.includes("Expected error message"));
}
```

## IDL (Interface Definition Language)

Anchor automatically generates IDL files that describe your program's interface:

```json
{
  "version": "0.1.0",
  "name": "my_program",
  "instructions": [
    {
      "name": "initialize",
      "accounts": [
        {
          "name": "myAccount",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "authority",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "systemProgram",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "data",
          "type": "u64"
        }
      ]
    }
  ],
  "accounts": [
    {
      "name": "MyAccount",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "data",
            "type": "u64"
          },
          {
            "name": "authority",
            "type": "publicKey"
          }
        ]
      }
    }
  ],
  "errors": [
    {
      "code": 6000,
      "name": "CustomError",
      "msg": "Custom error message"
    }
  ]
}
```

### Using IDL in Client

```typescript
import { Program, AnchorProvider, Idl } from "@coral-xyz/anchor";
import idl from "./target/idl/my_program.json";

const programId = new PublicKey("YOUR_PROGRAM_ID");
const program = new Program(idl as Idl, programId, provider);
```

## Deployment and Upgrades

### Deploy to Devnet

```bash
# Build program
anchor build

# Deploy
anchor deploy --provider.cluster devnet

# Verify deployment
solana program show <PROGRAM_ID> --url devnet
```

### Upgrade Program

```bash
# Build new version
anchor build

# Upgrade
anchor upgrade <PROGRAM_ID> \
  --program-keypair target/deploy/my_program-keypair.json \
  --provider.cluster devnet
```

### Make Program Immutable

```bash
solana program set-upgrade-authority <PROGRAM_ID> \
  --final \
  --url devnet
```

## Advanced Features

### Zero-Copy Deserialization

For large accounts, use zero-copy to avoid deserialization overhead:

```rust
#[account(zero_copy)]
pub struct LargeAccount {
    pub data: [u64; 1000],
}

#[derive(Accounts)]
pub struct UseLargeAccount<'info> {
    pub large_account: AccountLoader<'info, LargeAccount>,
}

pub fn use_large_account(ctx: Context<UseLargeAccount>) -> Result<()> {
    let large_account = ctx.accounts.large_account.load()?;
    let value = large_account.data[0];
    Ok(())
}
```

### Events

Emit events for off-chain indexing:

```rust
#[event]
pub struct TaskCreated {
    pub task_id: u64,
    pub description: String,
    pub timestamp: i64,
}

pub fn add_task(ctx: Context<AddTask>, description: String) -> Result<()> {
    // ... task creation logic ...
    
    emit!(TaskCreated {
        task_id: task.task_id,
        description: description.clone(),
        timestamp: Clock::get()?.unix_timestamp,
    });
    
    Ok(())
}
```

### Listening to Events (Client)

```typescript
const listener = program.addEventListener("TaskCreated", (event, slot) => {
  console.log("Task created:", event);
  console.log("Slot:", slot);
});

// Remove listener when done
program.removeEventListener(listener);
```

## Best Practices

1. **Use PDAs for Program-Owned Accounts**
   - Deterministic addresses
   - No private key management
   - Better security

2. **Validate All Inputs**
   - Use `require!` macro for runtime checks
   - Use constraints for account validation
   - Check string lengths and numeric ranges

3. **Handle Errors Properly**
   - Define custom error codes
   - Provide descriptive error messages
   - Use `Result<()>` return type

4. **Optimize Account Space**
   - Calculate exact space requirements
   - Use `#[account(zero_copy)]` for large accounts
   - Consider account reallocation if needed

5. **Test Thoroughly**
   - Write unit tests for business logic
   - Write integration tests for instructions
   - Test error cases and edge conditions
   - Use `solana-test-validator` for local testing

6. **Security Considerations**
   - Always validate account ownership
   - Check signer requirements
   - Validate PDA derivations
   - Be careful with arithmetic operations
   - Use `checked_add`, `checked_sub`, etc.

## Common Patterns

### Initialization Pattern

```rust
#[account(
    init,
    payer = authority,
    space = 8 + std::mem::size_of::<MyAccount>(),
    seeds = [b"my-account", authority.key().as_ref()],
    bump
)]
pub my_account: Account<'info, MyAccount>,
```

### Authority Pattern

```rust
#[account(
    mut,
    has_one = authority @ ErrorCode::Unauthorized
)]
pub my_account: Account<'info, MyAccount>,
pub authority: Signer<'info>,
```

### Reallocation Pattern

```rust
#[account(
    mut,
    realloc = 8 + 32 + 4 + new_data.len(),
    realloc::payer = authority,
    realloc::zero = false
)]
pub my_account: Account<'info, MyAccount>,
```

## Troubleshooting

### Common Errors

**Error: "Account not initialized"**
- Ensure account is initialized before use
- Check PDA derivation is correct

**Error: "Constraint violation"**
- Review account constraints
- Verify account relationships

**Error: "Insufficient funds"**
- Ensure payer has enough SOL
- Check rent-exempt minimum

**Error: "Program ID mismatch"**
- Update `declare_id!` with correct program ID
- Rebuild after changing program ID

## Source Attribution

This content is based on:

- **Anchor Framework Documentation**: https://www.anchor-lang.com/docs
- **Anchor GitHub Repository**: https://github.com/coral-xyz/anchor
- **Anchor Examples**: https://github.com/coral-xyz/anchor/tree/master/examples
- **Solana Cookbook - Anchor**: https://solanacookbook.com/references/anchor.html

## Next Steps

Now that you understand Anchor:

- Build more complex programs with multiple instructions
- Explore [SPL Token integration](../03-tokens/README.md) with Anchor
- Learn about [PDAs in depth](../04-pdas/README.md)
- Practice with [Exercises](../exercises/README.md)

## Additional Resources

- [Anchor Book](https://book.anchor-lang.com/) - Comprehensive guide to the Anchor framework from basics to advanced topics
- [Anchor by Example](https://examples.anchor-lang.com/) - Collection of example programs demonstrating Anchor features
- [Solana Playground](https://beta.solpg.io/) - Browser-based IDE for trying Anchor programs without local setup
- [Anchor Discord](https://discord.gg/anchor) - Community support for Anchor developers

## Exercises

Ready to build with Anchor? Check out the [Exercises](../exercises/README.md) section for hands-on practice!
